#' cleanUpload UI
#'
#' @param id Unique id for module instance.
#'
#' @keywords internal
cleanUploadUI <- function(id, multiple = TRUE) {
  ns <- NS(id)

  tagList(
    h2("Upload cleaned data"),
    fileInput(ns("upload"),
      label = span(
        "Select cleaned data Excel spreadsheet",
        bslib::tooltip(
          icon("info-circle"),
          "The data should be in the `.xlsx` format generated by the data cleaning tab. Multiple files can be uploaded.",
          placement = "right",
        )
      ),
      multiple = multiple,
      buttonLabel = "Upload...",
      width = "100%",
      accept = ".xlsx"
    ),
    verbatimTextOutput(ns("test")),
    uiOutput(ns("warn"))
  )
}

#' cleanUpload Server
#'
#' @param id Unique id for module instance.
#'
#' @keywords internal
cleanUpload_server <- function(id) {
  moduleServer(
    id,
    function(input,
             output,
             session) {
      ns <- session$ns
      send_message <- make_send_message(session)

      # create rv to hold error messages

      preparse_check <- reactiveVal(
        data.frame(message = character(),
                   level = integer())
      )

      # get uploaded data

      clean_data_list <- reactive({
        req(input$upload)

        files <- input$upload

        valid_files <- grepl("\\.xlsx$", files$name, ignore.case = TRUE)

        if (!all(valid_files)) {
          preparse_check(
            data.frame(
              message = c("Only Excel (`.xlsx`) files can be uploaded"),
              level = c(3)
            )
          )
          return(NULL)
        } else {
          purrr::map(files$datapath, ~ openxlsx::read.xlsx(.x, sheet = 1, sep.names = " "))
        }
      })

      uploaded_data <- reactive({
        if (length(clean_data_list()) == 1) {
          return(clean_data_list()[[1]])
        }
        if (length(clean_data_list()) > 1) { # stack dfs if multiple uploaded

          tryCatch({
            return(purrr::reduce(clean_data_list(), .f = dplyr::bind_rows))
          }, error = function(e) {
            error_message <- data.frame(
              message = c("Unable to combine uploaded data files"),
              level = c(3)
            )
            warning(paste0("Error combining data uploads: ", e$message))
            preparse_check(error_message)

            return(NULL)
          }
          )
        }
      })


      # run upload checks

      checks <- reactive({
        if (isTruthy(uploaded_data())) {
          vars <- c("Keep row?", "gender", "class", "School ID code")
          checks <- upload_checks_clean(uploaded_data(), vars = vars)
          return(checks)
        } else {
          return(preparse_check())
        }

      })


      # filter out excluded observations

      filtered_data <- reactive({
        req(uploaded_data())
        req(checks())


        if (any(checks()$level == 3)) {

          return(NULL)
        } else {
          uploaded_data() |>
            dplyr::filter(.data$`Keep row?` == 1) |>
            dplyr::select(-c("Keep row?", "Error messages", "Reviewer notes"))
        }
      })


      # create warning ui
      output$warn <- renderUI({
        req(clean_data_list, cancelOutput = TRUE)
        req(checks(), cancelOutput = TRUE)


        warnings <- purrr::pmap(
          checks(),
          make_warning
        )

        do.call(tagList, warnings)
      })

      return(filtered_data)
    }
  )
}

# UI
# cleanUploadUI('id')

# server
# cleanUpload_server('id')
